"""Utilities for blocking devices from network access."""

from __future__ import annotations

from collections.abc import Iterable, Mapping, MutableMapping
from dataclasses import dataclass

from .devices import Device, get_device_repository
from .firewall import FirewallManager
from .utils import logger

DEFAULT_RULESET = "LAN_IN"


@dataclass(frozen=True)
class LockOptions:
    """Options for generating firewall rules."""

    ruleset: str = DEFAULT_RULESET
    logging: bool = False
    description: str | None = "Generated by ubiquiti.lock.DeviceLocker"


class DeviceLocker:
    """Creates firewall rules that block devices from internet access."""

    def __init__(
        self,
        firewall: FirewallManager,
        *,
        options: LockOptions | None = None,
    ) -> None:
        self._firewall = firewall
        self._options = options or LockOptions()
        self._wan_group_id = self._firewall.get_wan_group_id()

    @property
    def options(self) -> LockOptions:
        return self._options

    def build_rule(
        self, device: Device, *, rule_index: int | None = None
    ) -> MutableMapping[str, object]:
        """Generate the rule payload that blocks a device."""
        opts = self._options
        index = rule_index if rule_index is not None else 20000
        dst_firewallgroup_ids: list[str] = []
        if self._wan_group_id:
            dst_firewallgroup_ids = [self._wan_group_id]

        rule: MutableMapping[str, object] = {
            "name": self._rule_name(device),
            "action": "drop",
            "enabled": True,
            "ruleset": opts.ruleset,
            "protocol": "all",
            "logging": opts.logging,
            "setting_preference": "manual",
            "rule_index": index,
            "src_mac_address": device.mac,
            "src_mac": device.mac,
            "src_firewallgroup_ids": [],
            "dst_firewallgroup_ids": dst_firewallgroup_ids,
            "src_address": "",
            "dst_address": "",
            "src_networkconf_id": "",
            "dst_networkconf_id": "",
            "src_networkconf_type": "NETv4",
            "dst_networkconf_type": "NETv4",
            "state_new": False,
            "state_established": False,
            "state_related": False,
            "state_invalid": False,
            "protocol_match_excepted": False,
            "icmp_typename": "",
            "dst_port": "",
            "ipsec": "",
        }

        if opts.description:
            rule["comments"] = opts.description

        logger.bind(device=device.name, mac=device.mac, index=index).debug(
            "Constructed firewall rule payload"
        )
        return rule

    def lock_device(self, device: Device) -> Mapping[str, object]:
        """Create a firewall rule that blocks a single device."""
        existing_rules = list(self._firewall.list_rules())
        rule_index = self._next_rule_index(existing_rules)
        rule = self.build_rule(device, rule_index=rule_index)
        created = self._firewall.create_rule(rule)
        logger.bind(device=device.name, rule_id=created.get("_id")).info(
            "Created firewall rule to lock device"
        )
        return created

    def lock_devices(self, devices: Iterable[Device]) -> Iterable[Mapping[str, object]]:
        """Lock multiple devices, yielding each created rule."""
        existing_rules = list(self._firewall.list_rules())
        next_index = self._next_rule_index(existing_rules)
        for device in devices:
            rule = self.build_rule(device, rule_index=next_index)
            next_index += 1
            created = self._firewall.create_rule(rule)
            logger.bind(device=device.name, rule_id=created.get("_id")).info(
                "Created firewall rule to lock device"
            )
            yield created

    def lock_owner(self, owner: str) -> Iterable[Mapping[str, object]]:
        """Lock all devices belonging to a specific owner."""
        logger.bind(owner=owner).debug("Locking all devices for owner")
        device_repo = get_device_repository()
        return self.lock_devices(device_repo.list_by_owner(owner))

    def is_device_locked(
        self,
        device: Device,
        rules: Iterable[Mapping[str, object]] | None = None,
    ) -> bool:
        """Determine whether a blocking rule already exists for the device."""
        return bool(self._matching_rules(device, rules))

    def unlock_device(self, device: Device) -> int:
        """Remove firewall rules blocking the given device, returning count removed."""
        logger.bind(device=device.name).debug("Unlocking single device")
        return self.unlock_devices([device])

    def unlock_devices(self, devices: Iterable[Device]) -> int:
        """Remove all blocking rules for the provided devices."""
        remaining_rules: list[Mapping[str, object]] = list(self._firewall.list_rules())
        removed = 0
        for device in devices:
            matches = self._matching_rules(device, remaining_rules)
            for rule in matches:
                rule_id = rule.get("_id")
                if not rule_id:
                    continue
                self._firewall.delete_rule(str(rule_id))
                removed += 1
                remaining_rules = [
                    r for r in remaining_rules if r.get("_id") != rule_id
                ]
                logger.bind(device=device.name, rule_id=rule_id).info(
                    "Removed firewall rule locking device"
                )
        return removed

    def unlock_owner(self, owner: str) -> int:
        """Remove blocking rules for all devices belonging to an owner."""
        logger.bind(owner=owner).debug("Unlocking all devices for owner")
        device_repo = get_device_repository()
        return self.unlock_devices(device_repo.list_by_owner(owner))

    def _matching_rules(
        self,
        device: Device,
        rules: Iterable[Mapping[str, object]] | None = None,
    ) -> list[Mapping[str, object]]:
        rule_iterable = (
            list(rules) if rules is not None else list(self._firewall.list_rules())
        )
        matches: list[Mapping[str, object]] = []
        for rule in rule_iterable:
            if self._rule_targets_device(rule, device):
                matches.append(rule)
        logger.bind(device=device.name, match_count=len(matches)).debug(
            "Matched existing firewall rules for device"
        )
        return matches

    @staticmethod
    def _rule_targets_device(rule: Mapping[str, object], device: Device) -> bool:
        mac_addresses = (
            str(rule.get("src_mac_address", "")).lower(),
            str(rule.get("src_mac", "")).lower(),
        )
        device_mac = device.mac.lower()
        if device_mac and device_mac in mac_addresses:
            return True

        name = str(rule.get("name", "")).lower()
        expected_name = DeviceLocker._rule_name(device).lower()
        return name == expected_name

    @staticmethod
    def _next_rule_index(rules: Iterable[Mapping[str, object]]) -> int:
        max_index = 19999
        for rule in rules:
            raw_value = rule.get("rule_index", 0)
            if isinstance(raw_value, (int, float, str)):
                try:
                    value = int(raw_value)
                except (TypeError, ValueError):
                    continue
            else:
                continue
            max_index = max(max_index, value)
        return max_index + 1

    @staticmethod
    def _rule_name(device: Device) -> str:
        return f"Block {device.name}"


__all__ = ["DeviceLocker", "LockOptions", "DEFAULT_RULESET"]
